# ------------------------------------------------------------------------------
# Publish packages to GHCR
#
# HOW THIS WORKS (high-level):
# 1) Triggers:
#    - On push to main (only if files under packages/** or common CI files changed)
#    - On tags matching v*.*.* (always builds ALL packages)
#    - Manual dispatch with:
#        inputs.changed_only (default true)  -> build only changed packages
#        inputs.packages     (optional list) -> build only the listed packages
#
# 2) Change detection:
#    - Diffs current commit vs previous and notes packages/<name>/ changed.
#    - If workflow/shared scripts changed, builds ALL packages.
#
# 3) Build strategy (per package):
#    - Build the package Dockerfile for linux/amd64 + linux/arm64.
#    - Detect base runtime user by loading an amd64 image locally.
#    - Build a tiny wrapper image FROM that image that:
#        * Creates /usr/share/versanode
#        * Copies vncp.config.yaml and README.md into the image
#        * Applies common labels (config paths, version, etc.)
#        * Sets org.opencontainers.image.description on the image config
#          **and** annotates the manifest index with the same description.
#
# 4) Tags:
#    - On tag builds, tag=the tag name (e.g., v1.2.3); else tag=latest
#    - Also pushes a short-SHA tag for traceability
#
# 5) Visibility:
#    - After pushing, tries to mark the just-built packages PUBLIC on GHCR
#      (best-effort; wonâ€™t fail if not permitted).
#
# 6) Caching:
#    - Uses GitHub Actions cache for buildx to speed up rebuilds.
#
# 7) Ownership:
#    - Uses ${{ github.repository_owner }} (lowercased) as the GHCR org/owner.
#
# NOTES:
# - Keep org.opencontainers.image.description in each package Dockerfile if you can.
# - This workflow also injects that description into the final wrapper AND
#   annotates the manifest index so the GHCR package page shows it.
# ------------------------------------------------------------------------------

name: Publish packages to GHCR

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
    paths:
      - 'packages/**'
      - '.github/workflows/**'
      - 'scripts/**'
      - 'common/**'
  workflow_dispatch:
    inputs:
      changed_only:
        description: "Build ONLY packages that changed"
        type: boolean
        default: true
      packages:
        description: "Comma/space separated package names (overrides detection)"
        required: false

concurrency:
  group: publish-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write
    env:
      OWNER: ${{ github.repository_owner }}
      DEFAULT_LICENSE: Apache-2.0
      VNCP_DIR: /usr/share/versanode
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tag
        id: vars
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Lowercase owner for image tags
        run: |
          echo "ORG=${OWNER,,}" >> "$GITHUB_ENV"
          echo "Using org: ${OWNER} -> ${ORG}"

      - name: Determine packages to build
        id: changed
        env:
          INPUT_CHANGED_ONLY: ${{ inputs.changed_only }}
          INPUT_PACKAGES: ${{ inputs.packages }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          all_pkgs() { (cd packages && ls -1d */ 2>/dev/null | sed 's:/$::'); }

          FORCE_ALL=0
          PKGS=()

          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]]; then
            FORCE_ALL=1
          fi

          if [[ -n "${INPUT_PACKAGES:-}" ]]; then
            mapfile -t PKGS < <(printf '%s\n' "${INPUT_PACKAGES//,/ }" | tr -s ' ,\n' '\n' | sed '/^$/d')
            echo "Manual selection: ${PKGS[*]}"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${INPUT_CHANGED_ONLY:-true}" == "false" ]]; then
            FORCE_ALL=1
          fi

          if [[ ${#PKGS[@]} -eq 0 && $FORCE_ALL -eq 0 ]]; then
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
            if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
              BASE="$(git rev-parse HEAD^ || echo '')"
            fi

            echo "Diff range: $BASE..$HEAD"
            CHANGED="$(git diff --name-only "$BASE" "$HEAD" -- \
              'packages/**' '.github/workflows/**' 'scripts/**' 'common/**' || true)"

            if grep -qE '^(\.github/workflows/|scripts/|common/)' <<< "$CHANGED"; then
              FORCE_ALL=1
            else
              mapfile -t PKGS < <(awk -F/ '/^packages\//{print $2}' <<< "$CHANGED" | sort -u)
            fi
          fi

          if [[ $FORCE_ALL -eq 1 ]]; then
            mapfile -t PKGS < <(all_pkgs)
          fi

          FILTERED=()
          for p in "${PKGS[@]:-}"; do
            [[ -d "packages/$p" ]] && FILTERED+=("$p")
          done
          PKGS=("${FILTERED[@]}")

          if [[ ${#PKGS[@]} -eq 0 ]]; then
            echo "No package changes detected."
            echo "PKG_LIST=" >> "$GITHUB_ENV"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will build: ${PKGS[*]}"
            printf 'PKG_LIST=%s\n' "${PKGS[*]}" >> "$GITHUB_ENV"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Build & push each package (labels + index annotation for description)
        if: steps.changed.outputs.changed == 'true' || github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ steps.vars.outputs.tag }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          export CREATED="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

          CACHE_KEY="${GITHUB_REF_NAME//\//_}"
          CACHE_FROM="type=gha,scope=${CACHE_KEY}"
          CACHE_TO="type=gha,scope=${CACHE_KEY},mode=max"

          if [[ -z "${PKG_LIST:-}" ]]; then
            echo "Nothing to build."
            exit 0
          fi

          BUILT_LIST=()

          for name in ${PKG_LIST}; do
            pkg="packages/${name}"
            echo "::group::Package: ${name}"
            if [[ ! -f "${pkg}/Dockerfile" ]]; then
              echo "No Dockerfile in ${pkg}, skipping."
              echo "::endgroup::"
              continue
            fi

            # Ensure VNCP files exist so COPY never fails
            [[ -f "${pkg}/vncp.config.yaml" ]] || printf 'name: %s\nversion: "%s"\n' "$name" "${TAG}" > "${pkg}/vncp.config.yaml"
            [[ -f "${pkg}/README.md"        ]] || printf '# %s\n\nAuto-generated README for %s.\n' "$name" "$name" > "${pkg}/README.md"

            # ---- Extract description with a tiny Python helper written to a temp file
            export PKG_DOCKERFILE="${pkg}/Dockerfile"
            export PKG_README="${pkg}/README.md"
            PY_HELPER="$(mktemp)"
cat >"$PY_HELPER" <<'PY'
import os, shlex, re, pathlib, sys
df = pathlib.Path(os.environ.get("PKG_DOCKERFILE","Dockerfile"))
rd = pathlib.Path(os.environ.get("PKG_README","README.md"))
def from_dockerfile():
    try:
        text = df.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""
    # join backslash-continued LABEL lines
    lines, buf = [], ""
    for raw in text.splitlines():
        if not buf: buf = raw
        else: buf += raw.lstrip()
        if buf.rstrip().endswith("\\"):
            buf = buf.rstrip()[:-1] + " "
            continue
        lines.append(buf); buf = ""
    for line in lines:
        m = re.match(r"\s*LABEL\s+(.*)$", line)
        if not m: continue
        try:
            parts = shlex.split(m.group(1))
        except Exception:
            parts = m.group(1).split()
        for part in parts:
            if "=" not in part: continue
            k, v = part.split("=", 1)
            if k.strip() == "org.opencontainers.image.description":
                return v.strip()
    return ""
def from_readme():
    try:
        txt = rd.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""
    # first non-empty, non-heading-underline line; strip leading '# '
    for line in txt.splitlines():
        s = line.strip()
        if not s: continue
        if set(s) <= {"="} or set(s) <= {"-"}:  # skip underlines
            continue
        return s.lstrip("#").strip()
    return ""
desc = from_dockerfile().strip()
if not desc:
    desc = from_readme().strip()
print(desc)
PY
            OCI_DESC="$(python3 "$PY_HELPER" || true)"
            rm -f "$PY_HELPER" || true
            # Normalize + truncate for GH limit (512 chars)
            OCI_DESC="${OCI_DESC//$'\r'/ }"; OCI_DESC="${OCI_DESC//$'\n'/ }"
            if (( ${#OCI_DESC} > 512 )); then OCI_DESC="${OCI_DESC:0:512}"; fi
            # Escape quotes (safe for buildx flags)
            OCI_DESC_ESC="${OCI_DESC//\"/\\\"}"
            echo "Package description: ${OCI_DESC:-<none>}"

            # Build base image (multi-arch) from the package Dockerfile
            RAW_TAG="${TAG}"
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              -t "ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              -t "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
              "${pkg}" --push

            # Inspect runtime user (local amd64 load, then remove)
            LOCAL_TAG="localinspect-${name}-${GITHUB_SHA}"
            docker buildx build \
              --provenance=false --sbom=false \
              --platform linux/amd64 \
              -t "${LOCAL_TAG}" \
              "${pkg}" --load
            BASE_USER="$(docker inspect --format '{{.Config.User}}' "${LOCAL_TAG}" || true)"
            docker rmi -f "${LOCAL_TAG}" >/dev/null 2>&1 || true
            [[ -n "${BASE_USER}" ]] || BASE_USER="root"
            echo "Detected base runtime user: ${BASE_USER}"

            # Wrapper Dockerfile (adds VNCP files; description also applied as a LABEL)
            WRAP_DF="$(mktemp)"; trap 'rm -f "$WRAP_DF"' EXIT
cat > "$WRAP_DF" <<'DF'
# syntax=docker/dockerfile:1.6
ARG BASE_IMAGE
ARG BASE_USER=root
ARG VNCP_DIR=/usr/share/versanode
FROM ${BASE_IMAGE}
ARG VNCP_DIR
ARG BASE_USER
USER 0
RUN install -d -m 0755 "${VNCP_DIR}"
COPY --chmod=0644 vncp.config.yaml "${VNCP_DIR}/vncp.config.yaml"
COPY --chmod=0644 README.md        "${VNCP_DIR}/README.md"
RUN chmod 0644 "${VNCP_DIR}/vncp.config.yaml" "${VNCP_DIR}/README.md"
USER ${BASE_USER}
DF

            # Common labels (+ description label here on the final image)
            LABELS=(
              --label "io.versanode.vncp.config.path=${VNCP_DIR}/vncp.config.yaml"
              --label "io.versanode.vncp.readme.path=${VNCP_DIR}/README.md"
              --label "org.opencontainers.image.title=${name}"
              --label "org.opencontainers.image.version=${TAG}"
              --label "org.opencontainers.image.revision=${GITHUB_SHA}"
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.url=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.created=${CREATED}"
              --label "org.opencontainers.image.vendor=${OWNER}"
              --label "org.opencontainers.image.licenses=${DEFAULT_LICENSE}"
              --label "org.opencontainers.image.description=${OCI_DESC_ESC}"
            )

            # Build wrapper multi-arch and:
            #  - push it
            #  - add an index-level annotation for description (so GHCR shows it)
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              --build-arg "BASE_IMAGE=ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              --build-arg "BASE_USER=${BASE_USER}" \
              --build-arg "VNCP_DIR=${VNCP_DIR}" \
              -f "$WRAP_DF" \
              "${LABELS[@]}" \
              -t "ghcr.io/${ORG}/${name}:${TAG}" \
              -t "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
              --push \
              -o "type=registry,annotation-index.org.opencontainers.image.description=${OCI_DESC_ESC}"

            BUILT_LIST+=("${name}")
            echo "::endgroup::"
          done

          printf 'BUILT_LIST=%s\n' "${BUILT_LIST[*]}" >> "$GITHUB_ENV"

      - name: Make newly built packages public (best effort)
        if: env.BUILT_LIST != ''
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            echo "gh CLI not found; skipping visibility update."
            exit 0
          fi
          for name in ${BUILT_LIST}; do
            echo "Setting visibility PUBLIC for: ${name}"
            gh api \
              -X PUT \
              -H "Accept: application/vnd.github+json" \
              "/orgs/${OWNER}/packages/container/${name}/visibility" \
              -f visibility=public || {
                echo "Warn: failed to set public for ${name} (permission or already public)."
              }
          done
