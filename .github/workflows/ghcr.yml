# ------------------------------------------------------------------------------
# Publish packages to GHCR
#
# HOW THIS WORKS (high-level):
# 1) Triggers:
#    - On push to main (only if files under packages/** or common CI files changed)
#    - On tags matching v*.*.* (always builds ALL packages)
#    - Manual dispatch with:
#        inputs.changed_only (default true)  -> build only changed packages
#        inputs.packages     (optional list) -> build only the listed packages
#
# 2) Change detection:
#    - Diffs current commit vs previous and notes packages/<name>/ changed.
#    - If workflow/shared scripts changed, builds ALL packages.
#
# 3) Build strategy (per package):
#    - Build the package Dockerfile for linux/amd64 + linux/arm64.
#    - Detect base runtime user by loading an amd64 image locally.
#    - Build a tiny wrapper image FROM that image that:
#        * Creates /usr/share/versanode
#        * Copies vncp.config.yaml and README.md into the image
#        * Applies common labels (config paths, version, source, etc.)
#        * Sets org.opencontainers.image.description on the image config
#          AND annotates the manifest index with the same description.
#
# 4) Tags:
#    - On tag builds, tag=the tag name (e.g., v1.2.3); else tag=latest
#    - Also pushes a short-SHA tag for traceability
#
# 5) Visibility:
#    - After pushing, tries to mark the just-built packages PUBLIC on GHCR
#      (best-effort; doesnâ€™t fail the job if not permitted).
#
# 6) Caching:
#    - Uses GitHub Actions cache for buildx to speed up rebuilds.
#
# 7) Ownership:
#    - Uses ${{ github.repository_owner }} (lowercased) as the GHCR org/owner.
#
# NOTES:
# - Prefer putting org.opencontainers.image.description in each package Dockerfile.
# - This workflow still injects that description into the final wrapper AND
#   annotates the manifest index so the GHCR package page shows it.
# ------------------------------------------------------------------------------

name: Publish packages to GHCR

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
    paths:
      - 'packages/**'
      - '.github/workflows/**'
      - 'scripts/**'
      - 'common/**'
  workflow_dispatch:
    inputs:
      changed_only:
        description: "Build ONLY packages that changed"
        type: boolean
        default: true
      packages:
        description: "Comma/space separated package names (overrides detection)"
        required: false

concurrency:
  group: publish-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write
    env:
      OWNER: ${{ github.repository_owner }}
      DEFAULT_LICENSE: Apache-2.0
      VNCP_DIR: /usr/share/versanode

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tag
        id: vars
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Lowercase owner for image tags
        run: |
          echo "ORG=${OWNER,,}" >> "$GITHUB_ENV"
          echo "Using org: ${OWNER} -> ${ORG}"

      - name: Determine packages to build
        id: changed
        env:
          INPUT_CHANGED_ONLY: ${{ inputs.changed_only }}
          INPUT_PACKAGES: ${{ inputs.packages }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          all_pkgs() { (cd packages && ls -1d */ 2>/dev/null | sed 's:/$::'); }

          FORCE_ALL=0
          PKGS=()

          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]]; then
            FORCE_ALL=1
          fi

          if [[ -n "${INPUT_PACKAGES:-}" ]]; then
            mapfile -t PKGS < <(printf '%s\n' "${INPUT_PACKAGES//,/ }" | tr -s ' ,\n' '\n' | sed '/^$/d')
            echo "Manual selection: ${PKGS[*]}"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${INPUT_CHANGED_ONLY:-true}" == "false" ]]; then
            FORCE_ALL=1
          fi

          if [[ ${#PKGS[@]} -eq 0 && $FORCE_ALL -eq 0 ]]; then
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
            if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
              BASE="$(git rev-parse HEAD^ || echo '')"
            fi
            echo "Diff range: $BASE..$HEAD"

            CHANGED="$(git diff --name-only "$BASE" "$HEAD" -- \
              'packages/**' '.github/workflows/**' 'scripts/**' 'common/**' || true)"

            if grep -qE '^(\.github/workflows/|scripts/|common/)' <<< "$CHANGED"; then
              FORCE_ALL=1
            else
              mapfile -t PKGS < <(awk -F/ '/^packages\//{print $2}' <<< "$CHANGED" | sort -u)
            fi
          fi

          if [[ $FORCE_ALL -eq 1 ]]; then
            mapfile -t PKGS < <(all_pkgs)
          fi

          FILTERED=()
          for p in "${PKGS[@]:-}"; do
            [[ -d "packages/$p" ]] && FILTERED+=("$p")
          done
          PKGS=("${FILTERED[@]}")

          if [[ ${#PKGS[@]} -eq 0 ]]; then
            echo "No package changes detected."
            echo "PKG_LIST=" >> "$GITHUB_ENV"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will build: ${PKGS[*]}"
            printf 'PKG_LIST=%s\n' "${PKGS[*]}" >> "$GITHUB_ENV"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

            - name: Build & push each package (with VNCP files injected)
        if: steps.changed.outputs.changed == 'true' || github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ steps.vars.outputs.tag }}
        shell: bash
        run: |
          set -euxo pipefail
          shopt -s nullglob
          export CREATED="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

          CACHE_KEY="${GITHUB_REF_NAME//\//_}"
          CACHE_FROM="type=gha,scope=${CACHE_KEY}"
          CACHE_TO="type=gha,scope=${CACHE_KEY},mode=max"

          if [[ -z "${PKG_LIST:-}" ]]; then
            echo "Nothing to build."
            exit 0
          fi

          # Track what we actually pushed, for visibility step
          BUILT_LIST=()

          for name in ${PKG_LIST}; do
            pkg="packages/${name}"
            echo "::group::Package: ${name}"
            if [[ ! -f "${pkg}/Dockerfile" ]]; then
              echo "No Dockerfile in ${pkg}, skipping."
              echo "::endgroup::"
              continue
            fi

            # Ensure VNCP files exist so COPY never fails
            if [[ ! -f "${pkg}/vncp.config.yaml" ]]; then
              printf 'name: %s\nversion: "%s"\n' "$name" "${TAG}" > "${pkg}/vncp.config.yaml"
            fi
            if [[ ! -f "${pkg}/README.md" ]]; then
              printf '# %s\n\nAuto-generated README for %s.\n' "$name" "$name" > "${pkg}/README.md"
            fi

            SHORT_SHA="${GITHUB_SHA::7}"

            # ------------------------------------------------------------------
            # 1) Build BASE (multi-arch) from the package's Dockerfile
            #    Tag as raw-${TAG} to avoid clobbering final image.
            # ------------------------------------------------------------------
            RAW_TAG="raw-${TAG}"
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              -t "ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              -t "ghcr.io/${ORG}/${name}:raw-${SHORT_SHA}" \
              --push \
              "${pkg}"

            # ------------------------------------------------------------------
            # 2) Inspect runtime user (local amd64 load)
            # ------------------------------------------------------------------
            LOCAL_TAG="localinspect-${name}-${SHORT_SHA}"
            docker buildx build \
              --provenance=false --sbom=false \
              --platform linux/amd64 \
              -t "${LOCAL_TAG}" \
              --load \
              "${pkg}"

            BASE_USER="$(docker inspect --format '{{.Config.User}}' "${LOCAL_TAG}" || true)"
            docker rmi -f "${LOCAL_TAG}" >/dev/null 2>&1 || true
            if [[ -z "${BASE_USER}" ]]; then BASE_USER="root"; fi
            echo "Detected base runtime user for ${name}: ${BASE_USER}"

            # ------------------------------------------------------------------
            # 3) Wrapper: inject VNCP files + common labels (multi-arch)
            #    FROM the freshly built raw image.
            #    NOTE: The description stays in the package's Dockerfile label.
            # ------------------------------------------------------------------
            WRAP_DOCKERFILE="$(mktemp)"
            {
              echo '# syntax=docker/dockerfile:1.6'
              echo 'ARG BASE_IMAGE'
              echo 'ARG BASE_USER=root'
              echo 'ARG VNCP_DIR=/usr/share/versanode'
              echo 'FROM ${BASE_IMAGE}'
              echo 'ARG VNCP_DIR'
              echo 'ARG BASE_USER'
              echo 'USER 0'
              echo 'RUN install -d -m 0755 "${VNCP_DIR}"'
              echo 'COPY --chmod=0644 vncp.config.yaml "${VNCP_DIR}/vncp.config.yaml"'
              echo 'COPY --chmod=0644 README.md        "${VNCP_DIR}/README.md"'
              echo 'RUN chmod 0644 "${VNCP_DIR}/vncp.config.yaml" "${VNCP_DIR}/README.md"'
              echo 'USER ${BASE_USER}'
            } > "$WRAP_DOCKERFILE"

            LABELS=(
              --label "io.versanode.vncp.config.path=/usr/share/versanode/vncp.config.yaml"
              --label "io.versanode.vncp.readme.path=/usr/share/versanode/README.md"
              --label "org.opencontainers.image.title=${name}"
              --label "org.opencontainers.image.version=${TAG}"
              --label "org.opencontainers.image.revision=${GITHUB_SHA}"
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.url=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.created=${CREATED}"
              --label "org.opencontainers.image.vendor=${OWNER}"
              --label "org.opencontainers.image.licenses=${DEFAULT_LICENSE}"
            )

            # All options before the context; context is LAST.
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              --build-arg "BASE_IMAGE=ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              --build-arg "BASE_USER=${BASE_USER}" \
              --build-arg "VNCP_DIR=${VNCP_DIR}" \
              -f "$WRAP_DOCKERFILE" \
              "${LABELS[@]}" \
              -t "ghcr.io/${ORG}/${name}:${TAG}" \
              -t "ghcr.io/${ORG}/${name}:${SHORT_SHA}" \
              --push \
              "${pkg}"

            rm -f "$WRAP_DOCKERFILE" || true

            BUILT_LIST+=("${name}")
            echo "::endgroup::"
          done

          # Expose list to later steps
          echo "BUILT_LIST=${BUILT_LIST[*]}" >> "$GITHUB_ENV"
