# ------------------------------------------------------------------------------
# Publish packages to GHCR (versa-node/*)
#
# HOW THIS WORKS
# 1) Triggers:
#    - push to main (if packages/** or common CI files changed)
#    - push tags v*.*.* (build ALL packages)
#    - manual (workflow_dispatch) with:
#        changed_only: build only changed (default true)
#        packages:     override with a list
#
# 2) Change detection:
#    - Diff current commit vs previous -> which packages/<name> changed
#    - If shared scripts/workflows changed -> build ALL
#
# 3) Build strategy (per package):
#    - Build the packageâ€™s Dockerfile for linux/amd64 + linux/arm64 (BASE image)
#    - Detect the BASE image runtime user (local amd64 load)
#    - Build a tiny WRAPPER image FROM that BASE which:
#       * Creates /usr/share/versanode
#       * Copies vncp.config.yaml and README.md
#       * Applies common labels
#       * **Re-applies** org.opencontainers.image.description (from the package Dockerfile)
#    - Push the WRAPPER as the final tag
#    - **Annotate the multi-arch index** with org.opencontainers.image.description
#
# 4) Tags:
#    - tag build => tag=${GITHUB_REF_NAME} (e.g. v1.2.3)
#    - branch build => tag=latest
#    - also push short-SHA tag
#
# 5) Caching:
#    - Buildx cache (gha scope per branch/tag)
#
# 6) Owner/org:
#    - ${{ github.repository_owner }} (lowercased) for ghcr.io/<org>/<name>
# ------------------------------------------------------------------------------

name: Publish packages to GHCR

on:
  push:
    branches: [ main ]
    tags:     [ 'v*.*.*' ]
    paths:
      - 'packages/**'
      - '.github/workflows/**'
      - 'scripts/**'
      - 'common/**'
  workflow_dispatch:
    inputs:
      changed_only:
        description: "Build ONLY packages that changed"
        type: boolean
        default: true
      packages:
        description: "Comma/space separated package names (overrides detection)"
        required: false

concurrency:
  group: publish-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write
    env:
      OWNER: ${{ github.repository_owner }}
      DEFAULT_LICENSE: Apache-2.0
      VNCP_DIR: /usr/share/versanode

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tag
        id: vars
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Lowercase owner for image tags
        run: |
          echo "ORG=${OWNER,,}" >> "$GITHUB_ENV"
          echo "Using org: ${OWNER} -> ${ORG}"

      - name: Determine packages to build
        id: changed
        env:
          INPUT_CHANGED_ONLY: ${{ inputs.changed_only }}
          INPUT_PACKAGES:     ${{ inputs.packages }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          all_pkgs() { (cd packages && ls -1d */ 2>/dev/null | sed 's:/$::'); }

          FORCE_ALL=0
          PKGS=()

          # Tag build => all
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]]; then
            FORCE_ALL=1
          fi

          # Manual override
          if [[ -n "${INPUT_PACKAGES:-}" ]]; then
            mapfile -t PKGS < <(printf '%s\n' "${INPUT_PACKAGES//,/ }" | tr -s ' ,\n' '\n' | sed '/^$/d')
            echo "Manual selection: ${PKGS[*]}"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${INPUT_CHANGED_ONLY:-true}" == "false" ]]; then
            FORCE_ALL=1
          fi

          if [[ ${#PKGS[@]} -eq 0 && $FORCE_ALL -eq 0 ]]; then
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
            if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
              BASE="$(git rev-parse HEAD^ || echo '')"
            fi
            echo "Diff range: $BASE..$HEAD"
            CHANGED="$(git diff --name-only "$BASE" "$HEAD" -- \
              'packages/**' '.github/workflows/**' 'scripts/**' 'common/**' || true)"

            # Any shared CI/scripting change => build all
            if grep -qE '^(\.github/workflows/|scripts/|common/)' <<< "$CHANGED"; then
              FORCE_ALL=1
            else
              mapfile -t PKGS < <(awk -F/ '/^packages\//{print $2}' <<< "$CHANGED" | sort -u)
            fi
          fi

          if [[ $FORCE_ALL -eq 1 ]]; then
            mapfile -t PKGS < <(all_pkgs)
          fi

          FILTERED=()
          for p in "${PKGS[@]:-}"; do
            [[ -d "packages/$p" ]] && FILTERED+=("$p")
          done
          PKGS=("${FILTERED[@]}")

          if [[ ${#PKGS[@]} -eq 0 ]]; then
            echo "No package changes detected."
            echo "PKG_LIST=" >> "$GITHUB_ENV"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will build: ${PKGS[*]}"
            printf 'PKG_LIST=%s\n' "${PKGS[*]}" >> "$GITHUB_ENV"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Build & push (with VNCP files, labels, and index annotation)
        if: steps.changed.outputs.changed == 'true' || github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ steps.vars.outputs.tag }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          export CREATED="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

          CACHE_KEY="${GITHUB_REF_NAME//\//_}"
          CACHE_FROM="type=gha,scope=${CACHE_KEY}"
          CACHE_TO="type=gha,scope=${CACHE_KEY},mode=max"

          if [[ -z "${PKG_LIST:-}" ]]; then
            echo "Nothing to build."
            exit 0
          fi

          BUILT_LIST=()

          for name in ${PKG_LIST}; do
            pkg="packages/${name}"
            echo "::group::Package: ${name}"
            if [[ ! -f "${pkg}/Dockerfile" ]]; then
              echo "No Dockerfile in ${pkg}, skipping."
              echo "::endgroup::"
              continue
            fi

            # Ensure VNCP files so COPY never fails
            if [[ ! -f "${pkg}/vncp.config.yaml" ]]; then
              printf 'name: %s\nversion: "%s"\n' "$name" "${TAG}" > "${pkg}/vncp.config.yaml"
            fi
            if [[ ! -f "${pkg}/README.md" ]]; then
              printf '# %s\n\nAuto-generated README for %s.\n' "$name" "$name" > "${pkg}/README.md"
            fi

            # Extract description from the package Dockerfile
            DESC="$(
              python3 - <<'PY' 2>/dev/null || true
              import re,sys
              p=sys.argv[1]
              try: s=open(p,'r',encoding='utf-8',errors='ignore').read()
              except: 
                  print(""); sys.exit(0)
              # handle LABEL k=v, LABEL "k"="v", multi-label lines
              m=re.search(r'org\.opencontainers\.image\.description\s*=\s*(?P<q>["\']?)(?P<v>.+?)(?P=q)(?:\s|$)', s)
              if m:
                  print(m.group('v').strip())
              else:
                  print("")
              PY
              "${pkg}/Dockerfile"
            )"

            # Build BASE multi-arch (package Dockerfile)
            RAW_TAG="${TAG}"
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              -t "ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              -t "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
              "${pkg}" --push

            # Inspect runtime user via local amd64 load
            LOCAL_TAG="localinspect-${name}-${GITHUB_SHA}"
            docker buildx build \
              --provenance=false --sbom=false \
              --platform linux/amd64 \
              -t "${LOCAL_TAG}" \
              "${pkg}" --load

            BASE_USER="$(docker inspect --format '{{.Config.User}}' "${LOCAL_TAG}" || true)"
            docker rmi -f "${LOCAL_TAG}" >/dev/null 2>&1 || true
            [[ -z "${BASE_USER}" ]] && BASE_USER="root"
            echo "Detected base runtime user: ${BASE_USER}"

            # Wrapper Dockerfile (adds VNCP files + labels), re-apply description
            WRAP_DOCKERFILE="$(mktemp)"
            {
              echo '# syntax=docker/dockerfile:1.6'
              echo 'ARG BASE_IMAGE'
              echo 'ARG BASE_USER=root'
              echo 'ARG VNCP_DIR=/usr/share/versanode'
              echo 'FROM ${BASE_IMAGE}'
              echo 'ARG VNCP_DIR'
              echo 'ARG BASE_USER'
              echo 'USER 0'
              echo 'RUN install -d -m 0755 "${VNCP_DIR}"'
              echo 'COPY --chmod=0644 vncp.config.yaml "${VNCP_DIR}/vncp.config.yaml"'
              echo 'COPY --chmod=0644 README.md        "${VNCP_DIR}/README.md"'
              echo 'RUN chmod 0644 "${VNCP_DIR}/vncp.config.yaml" "${VNCP_DIR}/README.md"'
              echo 'USER ${BASE_USER}'
            } > "$WRAP_DOCKERFILE"

            LABELS=(
              --label "io.versanode.vncp.config.path=${VNCP_DIR}/vncp.config.yaml"
              --label "io.versanode.vncp.readme.path=${VNCP_DIR}/README.md"
              --label "org.opencontainers.image.title=${name}"
              --label "org.opencontainers.image.version=${TAG}"
              --label "org.opencontainers.image.revision=${GITHUB_SHA}"
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.url=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.created=${CREATED}"
              --label "org.opencontainers.image.vendor=${OWNER}"
              --label "org.opencontainers.image.licenses=${DEFAULT_LICENSE}"
            )

            if [[ -n "${DESC}" ]]; then
              LABELS+=( --label "org.opencontainers.image.description=${DESC}" )
            fi

            # Build WRAPPER multi-arch (final)
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              --build-arg "BASE_IMAGE=ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              --build-arg "BASE_USER=${BASE_USER}" \
              --build-arg "VNCP_DIR=${VNCP_DIR}" \
              -f "$WRAP_DOCKERFILE" \
              "${LABELS[@]}" \
              -t "ghcr.io/${ORG}/${name}:${TAG}" \
              -t "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
              "${pkg}" --push

            # Annotate the multi-arch index with description (if we have one)
            if [[ -n "${DESC}" ]]; then
              docker buildx imagetools create \
                --tag "ghcr.io/${ORG}/${name}:${TAG}" \
                --annotation "org.opencontainers.image.description=${DESC}" \
                "ghcr.io/${ORG}/${name}:${TAG}"

              docker buildx imagetools create \
                --tag "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
                --annotation "org.opencontainers.image.description=${DESC}" \
                "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}"
            fi

            BUILT_LIST+=("${name}")
            echo "::endgroup::"
            rm -f "$WRAP_DOCKERFILE"
          done

          printf 'BUILT_LIST=%s\n' "${BUILT_LIST[*]}" >> "$GITHUB_ENV"
