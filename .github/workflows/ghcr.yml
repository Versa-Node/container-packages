# ------------------------------------------------------------------------------
# Publish packages to GHCR
#
# HOW THIS WORKS (high-level):
# 1) Triggers:
#    - On push to main (only if files under packages/** or common CI files changed)
#    - On tags matching v*.*.* (always builds ALL packages)
#    - Manual dispatch with:
#        inputs.changed_only (default true)  -> build only changed packages
#        inputs.packages     (optional list) -> build only the listed packages
#
# 2) Change detection:
#    - Compares current commit to the previous (or tag) and detects which
#      package directories under packages/<name>/ changed.
#    - If workflow or shared scripts changed, builds ALL packages.
#
# 3) Build strategy (per package):
#    - First build the package’s own Dockerfile for linux/amd64 + linux/arm64.
#      This image MUST contain its own org.opencontainers.image.description.
#    - Inspect a locally loaded amd64 image to detect the base runtime user.
#    - Build a tiny wrapper image FROM that freshly built image that:
#       * Creates /usr/share/versanode
#       * Copies vncp.config.yaml and README.md into the image
#       * Applies common labels (config paths, version, source, etc.)
#      (Description remains in the package Dockerfile.)
#
# 4) Tags:
#    - On tag builds, tag=the tag name (e.g., v1.2.3)
#    - On branch builds, tag=latest
#    - Also pushes a short-SHA tag for traceability
#
# 5) Visibility:
#    - After pushing, tries to mark just the packages built in this run as
#      PUBLIC on GHCR (best-effort; won’t fail the job if not permitted).
#
# 6) Caching:
#    - Uses GitHub Actions cache for buildx to speed up rebuilds.
#
# 7) Ownership:
#    - Uses ${{ github.repository_owner }} (lowercased) as the GHCR org/owner.
#
# NOTES:
# - Only org.opencontainers.image.description stays in each package Dockerfile.
# - This workflow injects the VNCP config + README and common labels uniformly.
# ------------------------------------------------------------------------------

name: Publish packages to GHCR

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
    paths:
      - 'packages/**'
      - '.github/workflows/**'
      - 'scripts/**'
      - 'common/**'
  workflow_dispatch:
    inputs:
      changed_only:
        description: "Build ONLY packages that changed"
        type: boolean
        default: true
      packages:
        description: "Comma/space separated package names (overrides detection)"
        required: false

concurrency:
  group: publish-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write
    env:
      OWNER: ${{ github.repository_owner }}   # raw owner (may have caps)
      DEFAULT_LICENSE: Apache-2.0
      VNCP_DIR: /usr/share/versanode
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # we need history for diff

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tag
        id: vars
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Lowercase owner for image tags
        run: |
          echo "ORG=${OWNER,,}" >> "$GITHUB_ENV"
          echo "Using org: ${OWNER} -> ${ORG}"

      - name: Determine packages to build
        id: changed
        env:
          INPUT_CHANGED_ONLY: ${{ inputs.changed_only }}
          INPUT_PACKAGES: ${{ inputs.packages }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          # Helper: list all package dir names
          all_pkgs() { (cd packages && ls -1d */ 2>/dev/null | sed 's:/$::'); }

          FORCE_ALL=0
          PKGS=()

          # If tag build -> build ALL
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]]; then
            FORCE_ALL=1
          fi

          # workflow_dispatch overrides
          if [[ -n "${INPUT_PACKAGES:-}" ]]; then
            mapfile -t PKGS < <(printf '%s\n' "${INPUT_PACKAGES//,/ }" | tr -s ' ,\n' '\n' | sed '/^$/d')
            echo "Manual selection: ${PKGS[*]}"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${INPUT_CHANGED_ONLY:-true}" == "false" ]]; then
            FORCE_ALL=1
          fi

          # Detect changed package dirs if not forced/all/manual
          if [[ ${#PKGS[@]} -eq 0 && $FORCE_ALL -eq 0 ]]; then
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
            if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
              BASE="$(git rev-parse HEAD^ || echo '')"
            fi

            echo "Diff range: $BASE..$HEAD"
            CHANGED="$(git diff --name-only "$BASE" "$HEAD" -- \
              'packages/**' '.github/workflows/**' 'scripts/**' 'common/**' || true)"

            # If common/workflow scripts changed, rebuild everything
            if grep -qE '^(\.github/workflows/|scripts/|common/)' <<< "$CHANGED"; then
              FORCE_ALL=1
            else
              mapfile -t PKGS < <(awk -F/ '/^packages\//{print $2}' <<< "$CHANGED" | sort -u)
            fi
          fi

          # Expand to ALL if requested
          if [[ $FORCE_ALL -eq 1 ]]; then
            mapfile -t PKGS < <(all_pkgs)
          fi

          # Filter out missing dirs (e.g., deleted)
          FILTERED=()
          for p in "${PKGS[@]:-}"; do
            [[ -d "packages/$p" ]] && FILTERED+=("$p")
          done
          PKGS=("${FILTERED[@]}")

          if [[ ${#PKGS[@]} -eq 0 ]]; then
            echo "No package changes detected."
            echo "PKG_LIST=" >> "$GITHUB_ENV"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will build: ${PKGS[*]}"
            printf 'PKG_LIST=%s\n' "${PKGS[*]}" >> "$GITHUB_ENV"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Build & push each package (with VNCP files injected)
        if: steps.changed.outputs.changed == 'true' || github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ steps.vars.outputs.tag }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          export CREATED="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

          CACHE_KEY="${GITHUB_REF_NAME//\//_}"
          CACHE_FROM="type=gha,scope=${CACHE_KEY}"
          CACHE_TO="type=gha,scope=${CACHE_KEY},mode=max"

          if [[ -z "${PKG_LIST:-}" ]]; then
            echo "Nothing to build."
            exit 0
          fi

          # Track what we actually pushed, for visibility step
          BUILT_LIST=()

          for name in ${PKG_LIST}; do
            pkg="packages/${name}"
            echo "::group::Package: ${name}"
            if [[ ! -f "${pkg}/Dockerfile" ]]; then
              echo "No Dockerfile in ${pkg}, skipping."
              echo "::endgroup::"
              continue
            fi

            # Ensure VNCP files exist so COPY never fails
            if [[ ! -f "${pkg}/vncp.config.yaml" ]]; then
              printf 'name: %s\nversion: "%s"\n' "$name" "${TAG}" > "${pkg}/vncp.config.yaml"
            fi
            if [[ ! -f "${pkg}/README.md" ]]; then
              printf '# %s\n\nAuto-generated README for %s.\n' "$name" "$name" > "${pkg}/README.md"
            fi

            # Build base image (multi-arch) from the package Dockerfile
            RAW_TAG="${TAG}"
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              -t "ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              -t "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
              "${pkg}" --push

            # Inspect runtime user (local amd64 load, then remove)
            LOCAL_TAG="localinspect-${name}-${GITHUB_SHA}"
            docker buildx build \
              --provenance=false --sbom=false \
              --platform linux/amd64 \
              -t "${LOCAL_TAG}" \
              "${pkg}" --load

            BASE_USER="$(docker inspect --format '{{.Config.User}}' "${LOCAL_TAG}" || true)"
            docker rmi -f "${LOCAL_TAG}" >/dev/null 2>&1 || true
            if [[ -z "${BASE_USER}" ]]; then BASE_USER="root"; fi
            echo "Detected base runtime user: ${BASE_USER}"

            # Wrapper Dockerfile: add VNCP files + labels, keep description in package Dockerfile
            WRAP_DOCKERFILE="$(mktemp)"
            trap 'rm -f "$WRAP_DOCKERFILE"' EXIT
            {
              echo '# syntax=docker/dockerfile:1.6'
              echo 'ARG BASE_IMAGE'
              echo 'ARG BASE_USER=root'
              echo 'ARG VNCP_DIR=/usr/share/versanode'
              echo 'FROM ${BASE_IMAGE}'
              echo 'ARG VNCP_DIR'
              echo 'ARG BASE_USER'
              echo 'USER 0'
              echo 'RUN install -d -m 0755 "${VNCP_DIR}"'
              echo 'COPY --chmod=0644 vncp.config.yaml "${VNCP_DIR}/vncp.config.yaml"'
              echo 'COPY --chmod=0644 README.md        "${VNCP_DIR}/README.md"'
              echo 'RUN chmod 0644 "${VNCP_DIR}/vncp.config.yaml" "${VNCP_DIR}/README.md"'
              echo 'USER ${BASE_USER}'
            } > "$WRAP_DOCKERFILE"

            LABELS=(
              --label "io.versanode.vncp.config.path=${VNCP_DIR}/vncp.config.yaml"
              --label "io.versanode.vncp.readme.path=${VNCP_DIR}/README.md"
              --label "org.opencontainers.image.title=${name}"
              --label "org.opencontainers.image.version=${TAG}"
              --label "org.opencontainers.image.revision=${GITHUB_SHA}"
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.url=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.created=${CREATED}"
              --label "org.opencontainers.image.vendor=${OWNER}"
              --label "org.opencontainers.image.licenses=${DEFAULT_LICENSE}"
            )
            # NOTE: org.opencontainers.image.description remains in each package's Dockerfile.

            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              --build-arg "BASE_IMAGE=ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              --build-arg "BASE_USER=${BASE_USER}" \
              --build-arg "VNCP_DIR=${VNCP_DIR}" \
              -f "$WRAP_DOCKERFILE" \
              "${LABELS[@]}" \
              -t "ghcr.io/${ORG}/${name}:${TAG}" \
              -t "ghcr.io/${ORG}/${name}:${GITHUB_SHA::7}" \
              "${pkg}" --push

            BUILT_LIST+=("${name}")
            echo "::endgroup::"
          done

          # Expose list to later steps
          printf 'BUILT_LIST=%s\n' "${BUILT_LIST[*]}" >> "$GITHUB_ENV"

      - name: Make newly built packages public (best effort)
        if: env.BUILT_LIST != ''
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            echo "gh CLI not found; skipping visibility update."
            exit 0
          fi

          for name in ${BUILT_LIST}; do
            echo "Setting visibility PUBLIC for: ${name}"
            gh api \
              -X PUT \
              -H "Accept: application/vnd.github+json" \
              "/orgs/${OWNER}/packages/container/${name}/visibility" \
              -f visibility=public || {
                echo "Warn: failed to set public for ${name} (insufficient permission or already public)."
              }
          done
