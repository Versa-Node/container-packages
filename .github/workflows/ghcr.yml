# ------------------------------------------------------------------------------
# Publish packages to GHCR â€” MANUAL
#
# HOW THIS WORKS (high-level):
# 1) Trigger: workflow_dispatch (manual run)
#    - inputs.tag          : tag to publish (e.g., latest, v1.2.3)
#    - inputs.packages     : optional space/comma list of package dirs under packages/
#    - inputs.make_public  : mark built GHCR packages as PUBLIC after push (default: true)
#    - inputs.push_short_sha: also push a <short-sha> tag for traceability (default: true)
#
# 2) Package selection:
#    - If you supply "packages", only those are built.
#    - Otherwise, it builds ALL direct subfolders under ./packages that contain a Dockerfile.
#
# 3) Build strategy (per package):
#    - Build the package's Dockerfile for linux/amd64+linux/arm64 as a "raw" image:
#        ghcr.io/<org>/<name>:raw-<tag> and :raw-<shortsha>
#      The package Dockerfile is expected to carry its own
#      `org.opencontainers.image.description` label.
#    - Do a local amd64 load to inspect and detect the base runtime user.
#    - Build a tiny wrapper image FROM the raw image that:
#        * creates /usr/share/versanode
#        * copies vncp.config.yaml + README.md
#        * applies common labels (config paths, source, version, etc.)
#      Pushes final multi-arch tags:
#        ghcr.io/<org>/<name>:<tag> and (optionally) :<shortsha>
#
# 4) Visibility:
#    - If enabled, sets visibility=public for the packages built in this run (best effort).
#
# 5) Caching:
#    - Uses GitHub Actions cache for Buildx to speed up rebuilds.
#
# 6) Ownership:
#    - Uses ${{ github.repository_owner }} (lowercased) as the GHCR org/owner.
#
# NOTES:
# - The image description that shows in GitHub Packages should come from each
#   package Dockerfile via `org.opencontainers.image.description`.
# - This workflow *does not* edit the description; it just ensures common VNCP
#   files/labels are injected consistently in a wrapper image.
# ------------------------------------------------------------------------------

name: Publish packages to GHCR

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to publish (e.g., latest or v1.2.3)"
        default: "latest"
        required: true
      packages:
        description: "Space/comma separated package names under packages/ (optional)"
        required: false
      make_public:
        description: "Set built packages to PUBLIC visibility"
        type: boolean
        default: true
      push_short_sha:
        description: "Also push a <short-sha> tag"
        type: boolean
        default: true

concurrency:
  group: publish-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write

    env:
      OWNER: ${{ github.repository_owner }}   # raw owner (may have caps)
      DEFAULT_LICENSE: Apache-2.0
      VNCP_DIR: /usr/share/versanode

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Lowercase owner for image namespace
        run: |
          echo "ORG=${OWNER,,}" >> "$GITHUB_ENV"
          echo "Using org: ${OWNER} -> ${ORG}"

      - name: Compute inputs and package list
        id: plan
        shell: bash
        env:
          INPUT_PACKAGES: ${{ inputs.packages }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          TAG_IN="${{ inputs.tag }}"
          if [[ -z "${TAG_IN}" ]]; then
            echo "Tag input is empty; defaulting to 'latest'"
            TAG_IN="latest"
          fi
          echo "tag=${TAG_IN}" >> "$GITHUB_OUTPUT"

          # Build package list
          if [[ -n "${INPUT_PACKAGES:-}" ]]; then
            # Normalize spaces/commas
            mapfile -t PKGS < <(printf '%s\n' "${INPUT_PACKAGES//,/ }" | tr -s ' \n' '\n' | sed '/^$/d')
          else
            # All subfolders under packages/ that contain a Dockerfile
            mapfile -t PKGS < <(cd packages && for d in */ ; do [[ -f "${d}Dockerfile" ]] && echo "${d%/}"; done)
          fi

          if [[ ${#PKGS[@]} -eq 0 ]]; then
            echo "No packages found to build."
            echo "PKG_LIST=" >> "$GITHUB_ENV"
            echo "has_pkgs=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will build: ${PKGS[*]}"
            printf 'PKG_LIST=%s\n' "${PKGS[*]}" >> "$GITHUB_ENV"
            echo "has_pkgs=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Build & push each package (with VNCP files injected)
        if: steps.plan.outputs.has_pkgs == 'true'
        env:
          TAG: ${{ steps.plan.outputs.tag }}
          PUSH_SHORT_SHA: ${{ inputs.push_short_sha }}
        shell: bash
        run: |
          set -euxo pipefail
          shopt -s nullglob

          export CREATED="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          SHORT_SHA="${GITHUB_SHA::7}"

          CACHE_KEY="${GITHUB_REF_NAME//\//_}"
          CACHE_FROM="type=gha,scope=${CACHE_KEY}"
          CACHE_TO="type=gha,scope=${CACHE_KEY},mode=max"

          # Track what we actually pushed, for visibility step
          BUILT_LIST=()

          for name in ${PKG_LIST}; do
            pkg="packages/${name}"
            echo "::group::Package: ${name}"
            if [[ ! -f "${pkg}/Dockerfile" ]]; then
              echo "No Dockerfile in ${pkg}, skipping."
              echo "::endgroup::"
              continue
            fi

            # Ensure VNCP files exist so COPY never fails
            if [[ ! -f "${pkg}/vncp.config.yaml" ]]; then
              printf 'name: %s\nversion: "%s"\n' "$name" "${TAG}" > "${pkg}/vncp.config.yaml"
            fi
            if [[ ! -f "${pkg}/README.md" ]]; then
              printf '# %s\n\nAuto-generated README for %s.\n' "$name" "$name" > "${pkg}/README.md"
            fi

            # ---------------------------
            # 1) Build RAW multi-arch image
            # ---------------------------
            RAW_TAG="raw-${TAG}"
            RAW_SHA_TAG="raw-${SHORT_SHA}"

            # All flags BEFORE the build context; context LAST.
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              -t "ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              -t "ghcr.io/${ORG}/${name}:${RAW_SHA_TAG}" \
              --push \
              "${pkg}"

            # ---------------------------
            # 2) Inspect runtime user (local amd64 load)
            # ---------------------------
            LOCAL_TAG="localinspect-${name}-${SHORT_SHA}"
            docker buildx build \
              --provenance=false --sbom=false \
              --platform linux/amd64 \
              -t "${LOCAL_TAG}" \
              --load \
              "${pkg}"

            BASE_USER="$(docker inspect --format '{{.Config.User}}' "${LOCAL_TAG}" || true)"
            docker rmi -f "${LOCAL_TAG}" >/dev/null 2>&1 || true
            if [[ -z "${BASE_USER}" ]]; then BASE_USER="root"; fi
            echo "Detected base runtime user for ${name}: ${BASE_USER}"

            # ---------------------------
            # 3) Wrapper: inject VNCP files + common labels (multi-arch)
            # ---------------------------
            WRAP_DOCKERFILE="$(mktemp)"
            {
              echo '# syntax=docker/dockerfile:1.6'
              echo 'ARG BASE_IMAGE'
              echo 'ARG BASE_USER=root'
              echo 'ARG VNCP_DIR=/usr/share/versanode'
              echo 'FROM ${BASE_IMAGE}'
              echo 'ARG VNCP_DIR'
              echo 'ARG BASE_USER'
              echo 'USER 0'
              echo 'RUN install -d -m 0755 "${VNCP_DIR}"'
              echo 'COPY --chmod=0644 vncp.config.yaml "${VNCP_DIR}/vncp.config.yaml"'
              echo 'COPY --chmod=0644 README.md        "${VNCP_DIR}/README.md"'
              echo 'RUN chmod 0644 "${VNCP_DIR}/vncp.config.yaml" "${VNCP_DIR}/README.md"'
              echo 'USER ${BASE_USER}'
            } > "$WRAP_DOCKERFILE"

            LABELS=(
              --label "io.versanode.vncp.config.path=/usr/share/versanode/vncp.config.yaml"
              --label "io.versanode.vncp.readme.path=/usr/share/versanode/README.md"
              --label "org.opencontainers.image.title=${name}"
              --label "org.opencontainers.image.version=${TAG}"
              --label "org.opencontainers.image.revision=${GITHUB_SHA}"
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.url=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.created=${CREATED}"
              --label "org.opencontainers.image.vendor=${OWNER}"
              --label "org.opencontainers.image.licenses=${DEFAULT_LICENSE}"
            )
            # NOTE: org.opencontainers.image.description stays in each package's Dockerfile.

            # Main tag
            FINAL_TAGS=( "-t" "ghcr.io/${ORG}/${name}:${TAG}" )
            # Optional short-sha tag
            if [[ "${PUSH_SHORT_SHA}" == "true" ]]; then
              FINAL_TAGS+=( "-t" "ghcr.io/${ORG}/${name}:${SHORT_SHA}" )
            fi

            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform linux/amd64,linux/arm64 \
              --build-arg "BASE_IMAGE=ghcr.io/${ORG}/${name}:raw-${TAG}" \
              --build-arg "BASE_USER=${BASE_USER}" \
              --build-arg "VNCP_DIR=${VNCP_DIR}" \
              -f "$WRAP_DOCKERFILE" \
              "${LABELS[@]}" \
              "${FINAL_TAGS[@]}" \
              --push \
              "${pkg}"

            rm -f "$WRAP_DOCKERFILE" || true

            BUILT_LIST+=("${name}")
            echo "::endgroup::"
          done

          # Expose list to later steps
          echo "BUILT_LIST=${BUILT_LIST[*]}" >> "$GITHUB_ENV"

      - name: Make newly built packages public (best effort)
        if: ${{ inputs.make_public && env.BUILT_LIST != '' }}
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v gh >/dev/null 2>&1; then
            echo "gh CLI not found; skipping visibility update."
            exit 0
          fi

          for name in ${BUILT_LIST}; do
            echo "Setting visibility PUBLIC for: ${name}"
            gh api \
              -X PUT \
              -H "Accept: application/vnd.github+json" \
              "/orgs/${OWNER}/packages/container/${name}/visibility" \
              -f visibility=public || {
                echo "Warn: failed to set public for ${name} (insufficient permission or already public)."
              }
          done
