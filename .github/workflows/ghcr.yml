# ------------------------------------------------------------------------------
# Publish packages to GHCR (versa-node/*)
# ------------------------------------------------------------------------------
name: Publish packages to GHCR

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
    paths:
      - 'packages/**'
      - '.github/workflows/**'
      - 'scripts/**'
      - 'common/**'
  workflow_dispatch:
    inputs:
      changed_only:
        description: "Build ONLY packages that changed"
        type: boolean
        default: true
      packages:
        description: "Comma/space separated package names (overrides detection)"
        required: false

concurrency:
  group: publish-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write
    env:
      OWNER: ${{ github.repository_owner }}
      DEFAULT_LICENSE: Apache-2.0
      VNCP_DIR: /usr/share/versanode

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tag
        id: vars
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi

      - name: Lowercase owner for image tags
        run: |
          echo "ORG=${OWNER,,}" >> "$GITHUB_ENV"
          echo "Using org: ${OWNER} -> ${ORG}"

      - name: Determine packages to build
        id: changed
        env:
          INPUT_CHANGED_ONLY: ${{ inputs.changed_only }}
          INPUT_PACKAGES:     ${{ inputs.packages }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          all_pkgs() { (cd packages && ls -1d */ 2>/dev/null | sed 's:/$::'); }

          FORCE_ALL=0
          PKGS=()

          # Tag build => all
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]]; then
            FORCE_ALL=1
          fi

          # Manual override
          if [[ -n "${INPUT_PACKAGES:-}" ]]; then
            mapfile -t PKGS < <(printf '%s\n' "${INPUT_PACKAGES//,/ }" | tr -s ' ,\n' '\n' | sed '/^$/d')
            echo "Manual selection: ${PKGS[*]}"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${INPUT_CHANGED_ONLY:-true}" == "false" ]]; then
            FORCE_ALL=1
          fi

          if [[ ${#PKGS[@]} -eq 0 && $FORCE_ALL -eq 0 ]]; then
            BASE="${{ github.event.before }}"; HEAD="${{ github.sha }}"
            if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
              BASE="$(git rev-parse HEAD^ || echo '')"
            fi
            echo "Diff range: $BASE..$HEAD"
            CHANGED="$(git diff --name-only "$BASE" "$HEAD" -- \
              'packages/**' '.github/workflows/**' 'scripts/**' 'common/**' || true)"

            # Any shared CI/scripting change => build all
            if grep -qE '^(\.github/workflows/|scripts/|common/)' <<< "$CHANGED"; then
              FORCE_ALL=1
            else
              mapfile -t PKGS < <(awk -F/ '/^packages\//{print $2}' <<< "$CHANGED" | sort -u)
            fi
          fi

          if [[ $FORCE_ALL -eq 1 ]]; then
            mapfile -t PKGS < <(all_pkgs)
          fi

          FILTERED=()
          for p in "${PKGS[@]:-}"; do
            [[ -d "packages/$p" ]] && FILTERED+=("$p")
          done
          PKGS=("${FILTERED[@]}")

          if [[ ${#PKGS[@]} -eq 0 ]]; then
            echo "No package changes detected."
            echo "PKG_LIST=" >> "$GITHUB_ENV"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will build: ${PKGS[*]}"
            printf 'PKG_LIST=%s\n' "${PKGS[*]}" >> "$GITHUB_ENV"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      # ---------------------- NEW: yq for package.yaml parsing ----------------------
      - name: Install yq
        run: |
          set -e
          YQ_VERSION=v4.44.3
          sudo wget -qO /usr/local/bin/yq \
            "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          sudo chmod +x /usr/local/bin/yq
          yq --version

      # ---------------------- UPDATED: per-package platform detection ----------------------
      - name: Build & push (respect per-package arch; skip missing)
        if: steps.changed.outputs.changed == 'true' || github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        env:
          TAG: ${{ steps.vars.outputs.tag }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          export CREATED="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"

          DEFAULT_PLATFORMS=("linux/amd64" "linux/arm64")

          CACHE_KEY="${GITHUB_REF_NAME//\//_}"
          CACHE_FROM="type=gha,scope=${CACHE_KEY}"
          CACHE_TO="type=gha,scope=${CACHE_KEY},mode=max"

          if [[ -z "${PKG_LIST:-}" ]]; then
            echo "Nothing to build."
            exit 0
          fi

          BUILT_LIST=()

          # helper: join array with commas
          join_csv() { local IFS=,; echo "$*"; }

          for name in ${PKG_LIST}; do
            pkg="packages/${name}"
            echo "::group::Package: ${name}"
            if [[ ! -f "${pkg}/Dockerfile" ]]; then
              echo "No Dockerfile in ${pkg}, skipping."
              echo "::endgroup::"
              continue
            fi

            # Ensure VNCP files so COPY never fails
            [[ -f "${pkg}/vncp.config.yaml" ]] || printf 'name: %s\nversion: "%s"\n' "$name" "${TAG}" > "${pkg}/vncp.config.yaml"
            [[ -f "${pkg}/README.md"        ]] || printf '# %s\n\nAuto-generated README for %s.\n' "$name" "$name" > "${pkg}/README.md"

            # Extract description (best-effort)
            DESC=""
            if [[ -f "${pkg}/Dockerfile" ]]; then
              _line="$(grep -Eio 'org\.opencontainers\.image\.description[[:space:]]*=[[:space:]]*.*' "${pkg}/Dockerfile" | head -n1 || true)"
              if [[ -n "${_line}" ]]; then
                _desc="${_line#*=}"; _desc="${_desc%%#*}"
                DESC="$(printf '%s' "${_desc}" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//' | sed -E 's/^["'\'']?(.*)["'\'']?$/\1/')"
              fi
            fi

            # Detect runtime user (last USER)
            BASE_USER="$(grep -Ei '^[[:space:]]*USER[[:space:]]+' "${pkg}/Dockerfile" 2>/dev/null | sed -E 's/^[[:space:]]*USER[[:space:]]+//' | sed -E 's/[[:space:]]+$//' | tail -n1 || true)"
            [[ -z "${BASE_USER}" ]] && BASE_USER="root"
            echo "Detected runtime user: ${BASE_USER}"

            RAW_TAG="${TAG}"
            SHORT="${GITHUB_SHA::7}"

            # ---- Requested platforms from package.yaml (fallback to default) ----
            REQ_PLATFORMS=()
            if [[ -f "${pkg}/package.yaml" ]]; then
              while IFS= read -r p; do
                [[ -n "$p" ]] && REQ_PLATFORMS+=("$p")
              done < <(yq -r '.arch[]? // empty' "${pkg}/package.yaml")
            fi
            if [[ ${#REQ_PLATFORMS[@]} -eq 0 ]]; then
              REQ_PLATFORMS=("${DEFAULT_PLATFORMS[@]}")
            fi
            echo "Requested platforms: $(join_csv "${REQ_PLATFORMS[@]}")"

            # ---- Intersect with upstream image platforms (if defined) ----
            UPSTREAM_IMAGE=""
            if [[ -f "${pkg}/package.yaml" ]]; then
              UPSTREAM_IMAGE="$(yq -r '.upstream.image // ""' "${pkg}/package.yaml")"
            fi

            CAND_PLATFORMS=("${REQ_PLATFORMS[@]}")
            if [[ -n "${UPSTREAM_IMAGE}" ]]; then
              echo "Upstream image: ${UPSTREAM_IMAGE}"
              if docker buildx imagetools inspect "${UPSTREAM_IMAGE}" >/tmp/inspect.txt 2>/dev/null; then
                mapfile -t UP_PLATS < <(grep -Eo 'linux/(amd64|arm64|arm/v[0-9]+|ppc64le|s390x|riscv64)' /tmp/inspect.txt | sort -u)
                if [[ ${#UP_PLATS[@]} -gt 0 ]]; then
                  echo "Upstream provides: $(join_csv "${UP_PLATS[@]}")"
                  TMP=()
                  for p in "${CAND_PLATFORMS[@]}"; do
                    for u in "${UP_PLATS[@]}"; do
                      [[ "$p" == "$u" ]] && TMP+=("$p")
                    done
                  done
                  if [[ ${#TMP[@]} -gt 0 ]]; then
                    CAND_PLATFORMS=("${TMP[@]}")
                  else
                    echo "NOTE: No overlap with upstream; keeping requested set."
                  fi
                fi
              else
                echo "Could not inspect upstream platforms (non-fatal)."
              fi
            fi

            # De-dup and finalize
            read -r -a PLATFORMS <<< "$(printf '%s\n' "${CAND_PLATFORMS[@]}" | sort -u | tr '\n' ' ')"
            if [[ ${#PLATFORMS[@]} -eq 0 ]]; then
              echo "No platforms to build for ${name}; skipping."
              echo "::endgroup::"
              continue
            fi
            PLAT_CSV="$(join_csv "${PLATFORMS[@]}")"
            echo "Final platforms: ${PLAT_CSV}"

            # ---------- BASE (multi-arch for final set) ----------
            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform "${PLAT_CSV}" \
              -t "ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              -t "ghcr.io/${ORG}/${name}:${SHORT}" \
              --push \
              "${pkg}"

            # ---------- WRAPPER (multi-arch) ----------
            WRAP_DOCKERFILE="$(mktemp)"
            {
              echo '# syntax=docker/dockerfile:1.6'
              echo 'ARG BASE_IMAGE'
              echo 'ARG BASE_USER=root'
              echo 'ARG VNCP_DIR=/usr/share/versanode'
              echo 'ARG VNCP_PROXIES="[]"'           # <--- DEFAULT ARG
              echo 'FROM ${BASE_IMAGE}'
              echo 'ARG VNCP_DIR'
              echo 'ARG BASE_USER'
              echo 'ARG VNCP_PROXIES'
              echo 'USER 0'
              echo 'RUN install -d -m 0755 "${VNCP_DIR}"'
              echo 'COPY --chmod=0644 vncp.config.yaml "${VNCP_DIR}/vncp.config.yaml"'
              echo 'COPY --chmod=0644 README.md        "${VNCP_DIR}/README.md"'
              echo 'RUN chmod 0644 "${VNCP_DIR}/vncp.config.yaml" "${VNCP_DIR}/README.md"'
              # Apply proxies label from ARG (value is $-escaped in the workflow)
              echo 'LABEL io.versanode.vncp.proxies="${VNCP_PROXIES}"'
              echo 'USER ${BASE_USER}'
            } > "$WRAP_DOCKERFILE"

            LABELS=(
              --label "io.versanode.vncp.config.path=${VNCP_DIR}/vncp.config.yaml"
              --label "org.opencontainers.image.title=${name}"
              --label "org.opencontainers.image.version=${TAG}"
              --label "org.opencontainers.image.revision=${GITHUB_SHA}"
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.url=https://github.com/${GITHUB_REPOSITORY}"
              --label "org.opencontainers.image.created=${CREATED}"
              --label "org.opencontainers.image.vendor=${OWNER}"
              --label "org.opencontainers.image.licenses=${DEFAULT_LICENSE}"
            )
            [[ -n "${DESC}" ]] && LABELS+=( --label "org.opencontainers.image.description=${DESC}" )

            README_FILE="${pkg}/README.md"
            ENC_LABEL_PREFIX="io.versanode.vncp.readme"

            README_B64="$(base64 -w0 "${README_FILE}")"
            CHUNK_SIZE=7000

            LABELS+=( --label "${ENC_LABEL_PREFIX}.encoding=b64,utf8" )
            LABELS+=( --label "${ENC_LABEL_PREFIX}.path=${VNCP_DIR}/README.md" )

            if [ "${#README_B64}" -le "${CHUNK_SIZE}" ]; then
              LABELS+=( --label "${ENC_LABEL_PREFIX}.single=${README_B64}" )
            else
              i=0
              while [ $(( i * CHUNK_SIZE )) -lt ${#README_B64} ]; do
                start=$(( i * CHUNK_SIZE ))
                LABELS+=( --label "${ENC_LABEL_PREFIX}.${i}=${README_B64:start:CHUNK_SIZE}" )
                i=$(( i + 1 ))
              done
              LABELS+=( --label "${ENC_LABEL_PREFIX}.parts=$i" )
            fi

            # --- NEW: load vncp-proxies.json -> --build-arg VNCP_PROXIES=... (escape $ to $$) ---
            BUILD_ARGS=( )
            PROX_FILE="${pkg}/vncp-proxies.json"
            if [[ -f "${PROX_FILE}" ]]; then
              echo "Found ${PROX_FILE}; injecting into label via ARG VNCP_PROXIES"
              raw_json="$(cat "${PROX_FILE}")"
              json_escaped="${raw_json//$/\$\$}"
              BUILD_ARGS+=( --build-arg "VNCP_PROXIES=${json_escaped}" )
            else
              # Optional: keep empty default "[]"
              BUILD_ARGS+=( --build-arg 'VNCP_PROXIES=[]' )
            fi

            docker buildx build \
              --provenance=false --sbom=false \
              --cache-from "${CACHE_FROM}" --cache-to "${CACHE_TO}" \
              --platform "${PLAT_CSV}" \
              --build-arg "BASE_IMAGE=ghcr.io/${ORG}/${name}:${RAW_TAG}" \
              --build-arg "BASE_USER=${BASE_USER}" \
              --build-arg "VNCP_DIR=${VNCP_DIR}" \
              "${BUILD_ARGS[@]}" \
              -f "$WRAP_DOCKERFILE" \
              "${LABELS[@]}" \
              -t "ghcr.io/${ORG}/${name}:${TAG}" \
              -t "ghcr.io/${ORG}/${name}:${SHORT}" \
              --push \
              "${pkg}"

            # OPTIONAL: per-arch tags only for successfully built arches
            for p in "${PLATFORMS[@]}"; do
              suffix="${p#linux/}"
              echo "Creating filtered tag :${TAG}-${suffix} for ${p}"
              docker buildx imagetools create \
                --tag "ghcr.io/${ORG}/${name}:${TAG}-${suffix}" \
                --filter "platform=${p}" \
                "ghcr.io/${ORG}/${name}:${TAG}" >/dev/null 2>&1 || true
            done

            BUILT_LIST+=("${name}")
            echo "::endgroup::"
            rm -f "$WRAP_DOCKERFILE"
          done

          printf 'BUILT_LIST=%s\n' "${BUILT_LIST[*]}" >> "$GITHUB_ENV"

      - name: Verify manifests (optional)
        if: env.BUILT_LIST != ''
        run: |
          for name in ${BUILT_LIST}; do
            echo "Inspecting ghcr.io/${ORG}/${name}:${{ steps.vars.outputs.tag }}"
            docker buildx imagetools inspect "ghcr.io/${ORG}/${name}:${{ steps.vars.outputs.tag }}" || true
          done
